@page "/meeting/{RoomId}"
@inject UserManager<AppUser> UserManager
@inject AuthenticationStateProvider AuthProvider
@inject NavigationManager Navigation
@inject IMeetingService MeetingService
@inject IJSRuntime JS
@rendermode InteractiveServer
@implements IDisposable

@if (isRoomFull)
{
    <div class="container-fluid vh-100 d-flex flex-column justify-content-center align-items-center">
        <div class="alert alert-danger text-center" role="alert">
            <h4 class="alert-heading">Кімната заповнена</h4>
            <p>Зустріч досягла максимальної кількості учасників. Спробуйте ще раз пізніше.</p>
            <button class="btn btn-primary" @onclick='() => Navigation.NavigateTo("/")'>Повернутися на головну</button>
        </div>
    </div>
}
else if (meeting != null)
{
    <div class="container-fluid vh-100 d-flex flex-column">
        <!-- Header -->
        <div class="p-3 bg-primary text-white shadow-sm d-flex justify-content-between align-items-center">
            <h3 class="mb-0">
                @meeting.MeetingName (ID: @RoomId)
                @if (!meeting.IsActive)
                {
                    <span class="badge bg-danger ms-2">Неактивна</span>
                }
            </h3>
            @if (meeting.ScheduledToStartAt != null && !meeting.IsActive)
            {
                <span class="fw-light">Заплановано на @meeting.ScheduledToStartAt?.ToLocalTime().ToString("g")</span>
            }
        </div>

        @if (meeting.IsActive)
        {
            <div class="d-flex">
                <!-- Participants Section -->
                <div class="p-3 bg-white shadow-sm" style="width: 1000px; overflow-y: auto;">
                    <h5 class="fw-bold mb-3 text-primary">Учасники (@Users.Count)</h5>
                    <div class="participant-grid">
                        @foreach (var user in Users)
                        {
                            <div class="card participant-tile shadow-sm border-0">
                                <div class="card-body p-2 text-center">
                                    @if (user.UserId == UserId && StreamActive)
                                    {
                                        <video id="video-$@user.UserId" class="avatar rounded mb-2" autoplay oncanplay="this.muted=true" playsinline></video>
                                    }
                                    else if (user.UserId != UserId && user.HasActiveStream)
                                    {
                                        <video id="video-$@user.UserId" class="avatar rounded mb-2" autoplay playsinline></video>
                                    }
                                    else
                                    {
                                        <img src="@user.AvatarUrl" class="avatar rounded-circle mb-2" alt="@user.UserName's avatar" />
                                    }
                                    <div class="fw-semibold">@user.UserName</div>
                                    <div class="d-flex justify-content-center gap-2 mt-1">
                                        <span class="badge @(user.IsMicrophoneEnabled ? "bg-success" : "bg-secondary")">
                                            <i class="bi @(user.IsMicrophoneEnabled ? "bi-mic-fill" : "bi-mic-mute-fill")"></i>
                                        </span>
                                        <span class="badge @(user.IsVideoEnabled ? "bg-success" : "bg-secondary")">
                                            <i class="bi @(user.IsVideoEnabled ? "bi-camera-video-fill" : "bi-camera-video-off-fill")"></i>
                                        </span>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
            </div>
                <!-- Screen Share Section -->
                <div class="p-3 bg-white shadow-sm" style="flex-grow: 1;">
                    <h5 class="fw-bold mb-3 text-primary">Трансляція екрану</h5>
                    @foreach (var user in Users)
                    {
                        @if (user.UserId == UserId && ScreenShareEnabled || user.UserId != UserId && user.IsScreenShareEnabled)
                        {
                            <div class="card shadow-sm border-0 mb-3">
                                <div class="card-body p-2">
                                    <h6>@user.UserName</h6>
                                    <video id="screen-@user.UserId" class="screen-share-video" autoplay playsinline="@(user.UserId == UserId ? "muted" : "" )"></video>
                                </div>
                            </div>
                        }
                    }
                </div>
                <div>
                <!-- Chat -->
                @if (showChats)
                {
                    <!-- Chat Section -->
                    <div class="card chat-container d-flex">
                        <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Чат</h5>
                            <div>
                                <label class="text-white me-2">
                                    <input type="checkbox" @bind="IsPrivate" class="me-1" /> Приватне повідомлення
                                </label>
                                @if (IsPrivate)
                                {
                                    <select @bind="SelectedPrivateUserId" class="form-select form-select-sm d-inline-block" style="width: auto;">
                                        <option disabled selected value="">-- Оберіть користувача --</option>
                                        @foreach (var user in Users.Where(u => u.UserId != UserId))
                                        {
                                            <option value="@user.UserId">@user.UserName</option>
                                        }
                                        @foreach (var user in DisconnectedButWithChatUsers.Where(u => u.UserId != UserId))
                                        {
                                            <option value="@user.UserId">@user.UserName (Офлайн)</option>
                                        }
                                    </select>
                                }
                            </div>
                        </div>
                        <div class="card-body chat-box p-3" style="overflow-y: auto;">
                            @if (!IsPrivate)
                            {
                                @foreach (var msg in ChatHistory)
                                {
                                    <div class="chat-message mb-2">
                                        <span class="fw-semibold">@msg.SenderName:</span>
                                        @if (msg.IsFile)
                                        {
                                            <a href="data:application/octet-stream;base64,@msg.FileContentBase64" download="@msg.FileName" class="text-primary">
                                                <i class="bi bi-file-earmark-arrow-down me-1"></i>@msg.FileName
                                            </a>
                                        }
                                        else
                                        {
                                            <span>@msg.Content</span>
                                        }
                                    </div>
                                }
                            }
                            else if (!string.IsNullOrWhiteSpace(SelectedPrivateUserId) && PrivateChatHistories.TryGetValue(SelectedPrivateUserId, out var privateMessages))
                            {
                                @foreach (var msg in privateMessages)
                                {
                                    <div class="chat-message mb-2">
                                        <span class="fw-semibold">@msg.SenderName:</span> 
                                        @if (msg.IsFile)
                                        {
                                            <a href="data:application/octet-stream;base64,@msg.FileContentBase64" download="@msg.FileName" class="text-primary">
                                                <i class="bi bi-file-earmark-arrow-down me-1"></i>@msg.FileName
                                            </a>
                                        }
                                        else
                                        {
                                            <span>@msg.Content</span>
                                        }
                                    </div>
                                }
                            }
                            else
                            {
                                <div class="text-muted text-center"><i>Немає приватних повідомлень.</i></div>
                            }
                        </div>
                        <div class="card-footer bg-light p-3">
                            <div class="input-group">
                                <input type="text" @bind="ChatMessage" @onkeypress="SendOnEnter" class="form-control" placeholder="Введіть повідомлення..." />
                                <button class="btn btn-primary" @onclick="SendMessage"><i class="bi bi-send"></i></button>
                            </div>
                            <div class="mt-2">
                                <InputFile OnChange="HandleFileSelected" class="form-control" />
                                @if (SelectedFile != null)
                                {
                                    <div class="mt-2">
                                        <span>Файл: @SelectedFile.Name (@(SelectedFile.Size / 1024) KB)</span>
                                        @if (SelectedFile.Size > 10000000)
                                        {
                                            <span class="text-danger ms-2">Розмір файлу перевищує ліміт 10MB.</span>
                                        }
                                        @if (CanSendFile)
                                        {
                                            <button class="btn btn-outline-primary btn-sm mt-1" @onclick="UploadFile">Надіслати файл</button>
                                        }
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
                <!-- Controls -->
                <div class="m-3 d-flex justify-content-center gap-3" style="bottom:auto">
                    <button class="btn btn-outline-primary btn-icon" @onclick="ToggleMic" title="@(MicEnabled ? "Вимкнути мікрофон" : "Увімкнути мікрофон")">
                        <i class="bi @(MicEnabled ? "bi-mic-fill" : "bi-mic-mute-fill")"></i>
                    </button>
                    <button class="btn btn-outline-primary btn-icon" @onclick="ToggleVideo" title="@(VideoEnabled ? "Вимкнути відео" : "Увімкнути відео")">
                        <i class="bi @(VideoEnabled ? "bi-camera-video-fill" : "bi-camera-video-off-fill")"></i>
                    </button>
                    <button class="btn btn-outline-primary btn-icon" @onclick="ToggleScreenShare" title="@(ScreenShareEnabled ? "Вимкнути трансляцію екрану" : "Увімкнути трансляцію екрану")">
                        <i class="bi @(ScreenShareEnabled ? "bi-display-fill" : "bi-display")"></i>
                    </button>
                    <button class="btn btn-outline-primary btn-icon" @onclick="ToggleChat" title="@(showChats ? "Відкрити чат" : "Закрити чат")">
                        <i class="bi @(showChats ? "bi-chat-left" : "bi-chat-left-text")"></i>
                    </button>
                    <button class="btn btn-danger" @onclick="ExitMeeting">
                        <i class="bi bi-box-arrow-right"></i> Вийти
                    </button>
                </div>
            </div>
        }
    </div>
}
else
{
    <div class="container-fluid vh-100 d-flex justify-content-center align-items-center">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}


<style>
    .vh-100 {
        height: 100vh;
    }

    .participant-tile {
        transition: transform 0.2s;
    }

    .participant-tile:hover {
        transform: translateY(-2px);
    }

    .avatar {
        width: 100px;
        height: 100px;
        object-fit: cover;
    }

    .chat-container {
        display: flex;
        flex-direction: column;
        min-height: 400px;
        max-height: 400px;
    }

    .chat-box {
        flex-grow: 1;
        overflow-y: auto;
        min-height: 0;
    }

    .chat-message {
        padding: 0.2rem;
        border-radius: 0.2rem;
        max-width: 80%;
    }

    .btn-icon {
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
    }

    .participant-video {
        width: 80px;
        height: 80px;
        object-fit: cover;
        border-radius: 50%;
    }

    .screen-share-video {
        width: 100%;
        max-height: 400px;
        object-fit: contain;
        border-radius: 8px;
    }

    @@media (max-width: 768px) {
        .participant-tile .avatar {
            width: 60px;
            height: 60px;
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            font-size: 1rem;
        }

        .participant-section {
            width: 200px;
        }
    }
</style>

@code {
    [Parameter]
    public string RoomId { get; set; } = default!;

    private Meeting meeting = new();

    private HubConnection? _hubConnection;
    private List<UserConnectionInfo> Users = new();
    private List<UserConnectionInfo> DisconnectedButWithChatUsers = new();

    private string UserId = "error";
    private string UserName = "error";
    private string AvatarUrl = "/avatars/default.png";
    private DotNetObjectReference<MeetingRoom>? dotNetRef;
    private bool MicEnabled = false;
    private bool VideoEnabled = false;
    private bool StreamActive = false;
    private bool ScreenShareEnabled = false;

    private string ChatMessage = "";
    private string SelectedPrivateUserId = "";
    private bool IsPrivate = false;
    private List<ChatMessage> ChatHistory = new();
    private Dictionary<string, List<ChatMessage>> PrivateChatHistories = new();

    private IBrowserFile? SelectedFile;
    private bool CanSendFile = true;

    private bool showChats = false;

    private bool isRoomFull = false;

    private void ToggleChat()
    {
        showChats = !showChats;
    }

    private async Task UploadFile()
    {
        if (SelectedFile == null || _hubConnection == null || _hubConnection.State != HubConnectionState.Connected)
            return;

        if (SelectedFile.Size > 10000000) // 10MB limit
        {
            return;
        }

        using var stream = SelectedFile.OpenReadStream(10000000); // Max 10MB
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        var fileBytes = ms.ToArray();

        var fileMessage = new ChatMessage
        {
            SenderId = UserId,
            SenderName = UserName,
            Content = $"Sent a file: {SelectedFile.Name}",
            FileName = SelectedFile.Name,
            Timestamp = DateTime.Now,
            FileContentBase64 = Convert.ToBase64String(fileBytes),
            ToUserId = IsPrivate ? SelectedPrivateUserId : null,
            IsFile = true,
        };

        Console.WriteLine("Sending file message: " + "from " + fileMessage.SenderId + " to " + fileMessage.ToUserId + "isFile: " + fileMessage.IsFile);

        await _hubConnection.InvokeAsync("SendFileMessage", RoomId, fileMessage);

        SelectedFile = null;
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        SelectedFile = e.File;

        if (SelectedFile.Size > 10000000) // 10MB limit
        {
            CanSendFile = false;
            return;
        }
        else
        {
            CanSendFile = true;
        }
    }

    [JSInvokable]
    public async Task LeaveMeetingFromJs()
    {
        //Console.WriteLine("LeaveMeetingFromJs Called");
        await ExitMeeting();
    }

    protected override async Task OnInitializedAsync()
    {
        meeting = await MeetingService.GetMeetingByIdAsync(RoomId);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Console.WriteLine($"OnAfterRenderAsync called at {DateTime.Now}, FirstRender: {firstRender}");

        if (firstRender)
        {
            try
            {
                var authState = await AuthProvider.GetAuthenticationStateAsync();
                var user = await UserManager.GetUserAsync(authState.User);

                if (user != null)
                {
                    UserId = user.Id;
                    UserName = user.DisplayName ?? "No Name";
                    AvatarUrl = user.AvatarUrl ?? "/avatars/default.png";
                }
                else
                {
                    UserName = "Guest";
                    AvatarUrl = "/avatars/default.png";
                    firstRender = true;
                    Navigation.NavigateTo("/login");
                }

                await InvokeAsync(StateHasChanged);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error loading user data: {ex.Message}");
            }

            _hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri("/meetinghub"))
                .WithAutomaticReconnect()
                .Build();

            _hubConnection.Reconnected += async (connectionId) =>
            {
                Console.WriteLine($"[${UserId}] HubConnection reconnected, new connectionId={connectionId}");
                try
                {
                    // Re-initialize WebRTCInterop with new DotNetObjectReference
                    dotNetRef = DotNetObjectReference.Create(this);
                    await JS.InvokeVoidAsync("WebRTCInterop.init", UserId, dotNetRef);
                    Console.WriteLine($"[${UserId}] Re-initialized WebRTCInterop after reconnection");
                    await _hubConnection.InvokeAsync("JoinMeeting", RoomId, UserId, UserName, AvatarUrl);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[${UserId}] Error on reconnection: {ex.Message}");
                    isRoomFull = true;
                    await InvokeAsync(StateHasChanged);
                }
            };

            Console.WriteLine($"Registering handlers for {UserName}");

            _hubConnection.On<UserConnectionInfo>("UserJoined", async (user) =>
            {
                Console.WriteLine($"UserJoined triggered for user: {user.UserName}, ConnectionId: {user.ConnectionId}"); //log
                if (!Users.Any(u => u.UserId == user.UserId))
                {
                    Users.Add(user);
                    Console.WriteLine($"Added user {user.UserName} to Users. Users count={Users.Count} (from UserJoined)");
                    if (StreamActive && (user.IsVideoEnabled || user.IsMicrophoneEnabled))
                    {
                        await JS.InvokeVoidAsync("WebRTCInterop.startOffer", user.UserId, UserId);
                    }
                    await InvokeAsync(StateHasChanged);
                }

                if (DisconnectedButWithChatUsers.Any(u => u.UserId == user.UserId))
                {
                    DisconnectedButWithChatUsers.RemoveAll(u => u.UserId == user.UserId);
                    Console.WriteLine($"Removed userId={user.UserId} from DisconnectedButWithChatUsers");
                    await InvokeAsync(StateHasChanged);
                }
            });

            _hubConnection.On<string>("RoomFull", async (message) =>
            {
                isRoomFull = true;
                Console.WriteLine($"Room full: {message}");
                await _hubConnection.StopAsync();
                await InvokeAsync(StateHasChanged);
            });

            _hubConnection.On<List<UserConnectionInfo>>("CurrentUsers", async (users) =>
            {
                Console.WriteLine("CurrentUsers triggered"); //log

                foreach (var user in users)
                {
                    Console.WriteLine($"  - {user.UserName}, ConnectionId: {user.ConnectionId}"); //log
                    if (!Users.Any(u => u.UserId == user.UserId))
                    {
                        Console.WriteLine($"Adding user from CurrentUsers: {user.UserName}"); //log
                        Users.Add(user);
                        if (StreamActive && (user.IsVideoEnabled || user.IsMicrophoneEnabled))
                        {
                            await JS.InvokeVoidAsync("WebRTCInterop.startOffer", user.UserId, UserId);
                        }
                    }
                }
                await InvokeAsync(StateHasChanged);
                Console.WriteLine($"Users count after CurrentUsers: {Users.Count}");
            });

            _hubConnection.On<string, string, string, bool>("UserStatusChanged", async (userId, connId, type, isEnabled) =>
            {
                var user = Users.FirstOrDefault(u => u.UserId == userId);
                if (user != null && user.UserId != UserId)
                {
                    Console.WriteLine($"UserStatusChanged: {user.UserName}, {type}={isEnabled}");
                    if (type == "video") user.IsVideoEnabled = isEnabled;
                    if (type == "microphone") user.IsMicrophoneEnabled = isEnabled;
                    if (type == "screen") user.IsScreenShareEnabled = isEnabled;
                    if (type == "stream") user.HasActiveStream = isEnabled;

                    if (type != "stream" && StreamActive && isEnabled)
                    {
                        await JS.InvokeVoidAsync("WebRTCInterop.startOffer", user.UserId, UserId);
                    }

                    await InvokeAsync(StateHasChanged);
                }
                else if (user != null)
                {
                    if (user.UserId == UserId)
                    {
                        if (type == "video")
                        {
                            VideoEnabled = isEnabled;
                            user.IsVideoEnabled = isEnabled;
                        }
                        if (type == "microphone")
                        {
                            MicEnabled = isEnabled;
                            user.IsMicrophoneEnabled = isEnabled;
                        }
                        if (type == "screen")
                        {
                            ScreenShareEnabled = isEnabled;
                            user.IsScreenShareEnabled = isEnabled;
                        }
                        if (type == "stream")
                        {
                            StreamActive = isEnabled;
                            user.HasActiveStream = isEnabled;
                        }
                    }

                    await InvokeAsync(StateHasChanged);
                }
            });

            _hubConnection.On<string, string>("UserLeft", async (connId, userName) =>
            {
                Console.WriteLine("UserLeft triggered"); // log
                Console.WriteLine($"UserLeft: {userName}, ConnectionId: {connId}"); //log
                var user = Users.FirstOrDefault(u => u.ConnectionId == connId);
                if (user != null)
                {
                    //Users.Remove(user);
                    Console.WriteLine($"Users count before removal: {Users.Count}"); //log
                    Console.WriteLine($"Removing user: {user.UserName}, UserId: {user.UserId}"); //log
                    Users.RemoveAll(u => u.UserId == user.UserId);
                    Console.WriteLine($"Users count after removal: {Users.Count}"); //log
                    if (PrivateChatHistories.ContainsKey(user.UserId) && !DisconnectedButWithChatUsers.Any(u => u.UserId == user.UserId))
                    {
                        DisconnectedButWithChatUsers.Add(user);
                    }
                    await JS.InvokeVoidAsync("WebRTCInterop.closePeerConnection", UserId, user.UserId);
                    await InvokeAsync(StateHasChanged);
                }
            });

            _hubConnection.On<ChatMessage>("ReceiveChatMessage", async (message) =>
            {
                ChatHistory.Add(message);
                await InvokeAsync(StateHasChanged);
            });

            _hubConnection.On<List<ChatMessage>>("SendChatHistory", async (history) =>
            {
                ChatHistory = history;
                await InvokeAsync(StateHasChanged);
            });

            _hubConnection.On<string, ChatMessage>("ReceivePrivateMessage", async (fromUserId, message) =>
            {
                if (!PrivateChatHistories.ContainsKey(fromUserId))
                {
                    PrivateChatHistories[fromUserId] = new List<ChatMessage>();
                }

                PrivateChatHistories[fromUserId].Add(message);
                await InvokeAsync(StateHasChanged);
            });

            _hubConnection.On<ChatMessage>("ReceiveFileMessage", async (fileMsg) =>
            {
                if (!string.IsNullOrEmpty(fileMsg.ToUserId))
                {
                    if (!PrivateChatHistories.ContainsKey(fileMsg.SenderId))
                    {
                        PrivateChatHistories[fileMsg.SenderId] = new List<ChatMessage>();
                    }
                    PrivateChatHistories[fileMsg.SenderId].Add(fileMsg);    
                }
                else
                {
                    ChatHistory.Add(fileMsg);
                }

                await InvokeAsync(StateHasChanged);
            });

            // Add WebRTC signaling handlers
            _hubConnection.On<string, string, bool>("ReceiveOffer", async (fromUserId, offer, isScreenShare) =>
            {
                try
                {
                    var answer = await JS.InvokeAsync<string>("WebRTCInterop.handleOffer", fromUserId, UserId, offer, isScreenShare);
                    Console.WriteLine($"Send answer invoked from={fromUserId}, to {UserId}, isScreenShare={isScreenShare}");
                    await _hubConnection.InvokeAsync("SendAnswer", fromUserId, answer, isScreenShare);
                    Console.WriteLine($"Handled offer from {fromUserId}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error handling offer from {fromUserId}: {ex.Message}");
                }
            });

            _hubConnection.On<string, string, bool>("ReceiveAnswer", async (fromUserId, answer, isScreenShare) =>
            {
                try
                {
                    await JS.InvokeVoidAsync("WebRTCInterop.handleAnswer", fromUserId, UserId, answer, isScreenShare);
                    Console.WriteLine($"Handled answer from {fromUserId}, to {UserId}, isScreenShare={isScreenShare}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error handling answer from {fromUserId}: {ex.Message}");
                }
            });

            _hubConnection.On<string, string, bool>("ReceiveIceCandidate", async (fromUserId, candidate, isScreenShare) =>
            {
                try
                {
                    await JS.InvokeVoidAsync("WebRTCInterop.handleIceCandidate", fromUserId, UserId, candidate, isScreenShare);
                    Console.WriteLine($"Handled ICE candidate from {fromUserId}, to {UserId}, isScreenShare={isScreenShare}");
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error handling ICE candidate from {fromUserId}: {ex.Message}");
                }
            });

            try
            {
                Console.WriteLine($"[${UserId}] Starting HubConnection");
                dotNetRef = DotNetObjectReference.Create(this);
                await JS.InvokeVoidAsync("WebRTCInterop.init", UserId, dotNetRef);
                await JS.InvokeVoidAsync("registerBeforeUnload", dotNetRef);
                await _hubConnection.StartAsync();
                Console.WriteLine($"[${UserId}] HubConnection started, state={_hubConnection.State}");
                await _hubConnection.InvokeAsync("JoinMeeting", RoomId, UserId, UserName, AvatarUrl); //
                Console.WriteLine($"[${UserId}] Called JoinMeeting with UserId: {UserId}, UserName: {UserName}, AvatarUrl: {AvatarUrl}");
                var currentUser = new UserConnectionInfo
                    {
                        UserId = UserId,
                        UserName = UserName,
                        AvatarUrl = AvatarUrl,
                        ConnectionId = _hubConnection.ConnectionId ?? string.Empty,
                        IsVideoEnabled = false,
                        IsMicrophoneEnabled = false,
                        HasActiveStream = false
                    };
                if (!Users.Any(u => u.UserId == UserId))
                {
                    Users.Add(currentUser);
                    Console.WriteLine($"[${UserId}] Adding current user: {UserName} to Users list (from OnAfterRenderAsync)");
                    await InvokeAsync(StateHasChanged);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[${UserId}] Error initializing: {ex.Message}");
            }
        }
        
        if (_pendingLocalStreamUpdate && StreamActive)
        {
            try
            {
                // Check if video element exists and set stream
                var videoElementId = $"video-${UserId}";
                await InvokeAsync(StateHasChanged);
                var streamSet = await JS.InvokeAsync<bool>("WebRTCInterop.setLocalStream", UserId, videoElementId);
                if (!streamSet)
                {
                    Console.WriteLine($"Failed to set local stream for {videoElementId}");
                }
                _pendingLocalStreamUpdate = false;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error setting local stream: {ex.Message}");
            }
        }
    }

    [JSInvokable]
    public async Task SendOffer(string toUserId, string offer, bool isScreenShare = false)
    {
        Console.WriteLine($"SendOffer invoked for toUserId={toUserId}, isScreenShare={isScreenShare}");
        await _hubConnection!.InvokeAsync("SendOffer", toUserId, offer, isScreenShare);
    }

    [JSInvokable]
    public async Task SendIceCandidate(string toUserId, string candidate, bool isScreenShare = false)
    {
        Console.WriteLine($"SendIceCandidate invoked for toUserId={toUserId}, isScreenShare={isScreenShare}");
        await _hubConnection!.InvokeAsync("SendIceCandidate", toUserId, candidate, isScreenShare);
    }

    [JSInvokable]
    public async Task OnRemoteStream(string remoteUserId, string streamId, bool isScreenShare = false)
    {
        var videoElementId = isScreenShare ? $"screen-{remoteUserId}" : $"video-{remoteUserId}";
        try
        {
            Console.WriteLine($"OnRemoteStream: remoteUserId={remoteUserId}, videoElementId={videoElementId}, streamId={streamId}, isScreenShare={isScreenShare}");
            await InvokeAsync(StateHasChanged); // Оновлюємо DOM
            var videoElementExists = await JS.InvokeAsync<bool>("WebRTCInterop.elementExists", videoElementId);
            Console.WriteLine($"Video element {videoElementId} exists: {videoElementExists}");
            if (videoElementExists)
            {
                var streamSet = await JS.InvokeAsync<bool>("WebRTCInterop.setRemoteStream", UserId, remoteUserId, videoElementId);
                if (!streamSet)
                {
                    Console.WriteLine($"[{UserId}] Failed to set remote stream for {videoElementId}");
                }
            }
            else
            {
                Console.WriteLine($"Video element {videoElementId} not found in DOM");
            }
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error setting remote stream for {remoteUserId}: {ex.Message}");
        }
    }

    private bool _pendingLocalStreamUpdate = false;

    private async Task ToggleMic()
    {
        MicEnabled = !MicEnabled;
        StreamActive = VideoEnabled || MicEnabled;

        Console.WriteLine($"ToggleMic: IsMicrophoneEnabled={MicEnabled}, StreamActive={StreamActive}");

        try
        {
            if (StreamActive)
            {
                var mediaStarted = await JS.InvokeAsync<bool>("WebRTCInterop.startMedia", UserId, VideoEnabled, MicEnabled);
                if (mediaStarted)
                {
                    var videoElementId = $"video-${UserId}";
                    await InvokeAsync(StateHasChanged); // Ensure DOM updates
                    var streamSet = await JS.InvokeAsync<bool>("WebRTCInterop.setLocalStream", UserId, videoElementId);
                    if (!streamSet)
                    {
                        Console.WriteLine($"Failed to set local stream for ${videoElementId}");
                    }
                }
                else
                {
                    Console.WriteLine("Failed to start media for user ${UserId}");
                    MicEnabled = false;
                    StreamActive = VideoEnabled;
                }
            }
            else
            {
                await JS.InvokeVoidAsync("WebRTCInterop.stopMedia", UserId);
            }
            await _hubConnection?.InvokeAsync("UpdateStatus", RoomId, "microphone", MicEnabled, UserId);
            await _hubConnection?.InvokeAsync("UpdateStatus", RoomId, "stream", StreamActive, UserId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in ToggleMic: ${ex.Message}");
            MicEnabled = false;
            StreamActive = VideoEnabled;
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleVideo()
    {
        VideoEnabled = !VideoEnabled;
        StreamActive = VideoEnabled || MicEnabled;

        Console.WriteLine($"ToggleVideo: IsVideoEnabled={VideoEnabled}, StreamActive={StreamActive}");

        try
        {
            if (StreamActive)
            {
                var mediaStarted = await JS.InvokeAsync<bool>("WebRTCInterop.startMedia", UserId, VideoEnabled, MicEnabled);
                if (mediaStarted)
                {
                    var videoElementId = $"video-${UserId}";
                    await InvokeAsync(StateHasChanged);
                    var streamSet = await JS.InvokeAsync<bool>("WebRTCInterop.setLocalStream", UserId, videoElementId);
                    if (!streamSet)
                    {
                        Console.WriteLine($"Failed to set local stream for ${videoElementId}");
                    }
                }
                else
                {
                    Console.WriteLine($"Failed to start media for user ${UserId}");
                    VideoEnabled = false;
                    StreamActive = MicEnabled;
                }
            }
            else
            {
                await JS.InvokeVoidAsync("WebRTCInterop.stopMedia", UserId);
            }
            await _hubConnection?.InvokeAsync("UpdateStatus", RoomId, "video", VideoEnabled, UserId);
            await _hubConnection?.InvokeAsync("UpdateStatus", RoomId, "stream", StreamActive, UserId);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in ToggleVideo: ${ex.Message}");
            VideoEnabled = false;
            StreamActive = MicEnabled;
        }
        await InvokeAsync(StateHasChanged);
    }

    private async Task ToggleScreenShare()
    {
        ScreenShareEnabled = !ScreenShareEnabled;
        StreamActive = VideoEnabled || MicEnabled || ScreenShareEnabled;

        Console.WriteLine($"ToggleScreenShare: IsScreenShareEnabled={ScreenShareEnabled}, StreamActive={StreamActive}");

        try
        {
            if (ScreenShareEnabled)
            {
                var mediaStarted = await JS.InvokeAsync<bool>("WebRTCInterop.startScreenShare", UserId);
                if (mediaStarted)
                {
                    var videoElementId = $"screen-{UserId}";
                    await InvokeAsync(StateHasChanged); // Оновлюємо DOM
                    var videoElementExists = await JS.InvokeAsync<bool>("WebRTCInterop.elementExists", videoElementId);
                    Console.WriteLine($"Before setLocalStream: videoElementId={videoElementId}, exists={videoElementExists}");
                    if (!videoElementExists)
                    {
                        Console.WriteLine($"Video element {videoElementId} not found, retrying after delay");
                        await Task.Delay(100); // Даємо час на рендеринг
                        await InvokeAsync(StateHasChanged);
                    }
                    var streamSet = await JS.InvokeAsync<bool>("WebRTCInterop.setLocalStream", UserId, videoElementId);
                    if (!streamSet)
                    {
                        Console.WriteLine($"Failed to set screen share stream for {videoElementId}");
                        ScreenShareEnabled = false;
                        StreamActive = VideoEnabled || MicEnabled;
                    }
                    else
                    {
                        foreach (var user in Users.Where(u => u.UserId != UserId && (u.IsVideoEnabled || u.IsMicrophoneEnabled || u.IsScreenShareEnabled)))
                        {
                            Console.WriteLine($"Starting screen share offer for userId={user.UserId}");
                            await JS.InvokeVoidAsync("WebRTCInterop.startOffer", user.UserId, UserId, true);
                        }
                    }
                }
                else
                {
                    Console.WriteLine($"Failed to start screen share for user {UserId}");
                    ScreenShareEnabled = false;
                    StreamActive = VideoEnabled || MicEnabled;
                }
            }
            else
            {
                await JS.InvokeVoidAsync("WebRTCInterop.stopScreenShare", UserId);
                foreach (var user in Users.Where(u => u.UserId != UserId))
                {
                    await JS.InvokeVoidAsync("WebRTCInterop.closePeerConnection", UserId, user.UserId, true);
                    if (VideoEnabled || MicEnabled)
                    {
                        await JS.InvokeVoidAsync("WebRTCInterop.startOffer", user.UserId, UserId, false);
                    }
                }
            }

            await _hubConnection!.InvokeAsync("UpdateStatus", RoomId, "screen", ScreenShareEnabled, UserId);
            await _hubConnection!.InvokeAsync("UpdateStatus", RoomId, "stream", StreamActive, UserId);
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in ToggleScreenShare: {ex.Message}");
            ScreenShareEnabled = false;
            StreamActive = VideoEnabled || MicEnabled;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task ExitMeeting()
    {
        try
        {
            await JS.InvokeVoidAsync("WebRTCInterop.dispose", UserId);
            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected && UserId != "error")
            {
                await _hubConnection.InvokeAsync("LeaveMeeting", RoomId, UserId, UserName);
                await _hubConnection.StopAsync();
                await _hubConnection.DisposeAsync();
                _hubConnection = null;
            }

            try
            {
                await JS.InvokeVoidAsync("WebRTCInterop.dispose", UserId);
                await JS.InvokeVoidAsync("unregisterBeforeUnload");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error disposing WebRTC or unregistering: {ex.Message}");
            }

            Users.Clear();
            Navigation.NavigateTo("/");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error exiting meeting: {ex.Message}");
            await InvokeAsync(StateHasChanged);
        }
    }

    [JSInvokable]
    public async Task OnBeforeUnload()
    {
        //Console.WriteLine("OnBeforeUnload invoked");
        // Call ExitMeeting only if the hub connection is active
        if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected && UserId != "error")
        {
            await ExitMeeting();
        }
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
        _hubConnection?.DisposeAsync().GetAwaiter().GetResult();
        Console.WriteLine($"[${UserId}] Disposed MeetingRoom component");
    }

    private async Task SendMessage()
    {
        if (string.IsNullOrWhiteSpace(ChatMessage)) return;

        if (!IsPrivate)
        {
            await _hubConnection.InvokeAsync("SendChatMessage", RoomId, UserId, UserName, ChatMessage);
        }
        else if (!string.IsNullOrWhiteSpace(SelectedPrivateUserId))
        {
            await _hubConnection.InvokeAsync("SendPrivateMessage", RoomId, UserId, SelectedPrivateUserId, ChatMessage);
        }

        ChatMessage = "";
    }

    private async Task SendOnEnter(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await SendMessage();
        }
    }
}
